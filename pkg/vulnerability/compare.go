package vulnerability

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"wizscan/pkg/wizapi"
	"wizscan/pkg/wizcli"

	"github.com/google/uuid"
)

type IntegrationData struct {
	IntegrationId string       `json:"integrationId"`
	DataSources   []DataSource `json:"dataSources"`
}

type DataSource struct {
	Id           string    `json:"id"`
	AnalysisDate time.Time `json:"analysisDate"`
	Assets       []Asset   `json:"assets"`
}

type Asset struct {
	AssetIdentifier       AssetIdentifier        `json:"assetIdentifier"`
	VulnerabilityFindings []VulnerabilityFinding `json:"vulnerabilityFindings"`
}

type AssetIdentifier struct {
	CloudPlatform string `json:"cloudPlatform"`
	ProviderId    string `json:"providerId"`
}

type VulnerabilityFinding struct {
	Id                      string `json:"id"`
	Name                    string `json:"name"`
	DetailedName            string `json:"detailedName"`
	ExternalDetectionSource string `json:"externalDetectionSource"`
	Severity                string `json:"severity"`
	ExternalFindingLink     string `json:"externalFindingLink"`
	Version                 string `json:"version"`
	Source                  string `json:"source"`
	FixedVersion            string `json:"fixedVersion"`
	Remediation             string `json:"remediation"`
	ValidatedAtRuntime      bool   `json:"validatedAtRuntime"`
	Description             string `json:"description"`
}

func CompareVulnerabilities(scanResult wizcli.AggregatedScanResults, knownVulns []wizapi.VulnerabilityNode) (Asset, error) {

	// Instantiate assetVulns with an empty slice of VulnerabilityFinding
	assetVulns := Asset{
		VulnerabilityFindings: make([]VulnerabilityFinding, 0),
	}

	for _, lib := range scanResult.Libraries {
		for _, vuln := range lib.Vulnerabilities {
			// Then, compare for known vulnerabilities
			ignoreVuln := false
			newUUID := uuid.New()
			id := newUUID.String()
			vulnCompare := ""
			path := ""
			var err error
			for _, kv := range knownVulns {
				path, err = extractPath(kv.Description)
				if err != nil {
					path = ""
				}
				//if !strings.HasPrefix(kv.ID, "WIZCLI") {
				if kv.DataSourceName == "" {
					// We are now comparing vulns found by Wiz disk scanner
					if vuln.Name == kv.Name && lib.Name == kv.DetailedName && vuln.FixedVersion == kv.FixedVersion && lib.DetectionMethod == kv.DetectionMethod && lib.Path == path {
						// Match says it's an existing vuln from Wiz disk scanner so, ignore
						vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tLibrary: %s\n\tPath: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Name, kv.ID, "Library", lib.Name, lib.Path, lib.Version, "Ignore")
						id = kv.ID
						ignoreVuln = true
					}
					//} else if strings.HasPrefix(kv.ID, "WIZCLI") {
				} else if kv.DataSourceName == "WizCLI" {
					// We are now comparing vulns found by wizcli scanner
					if vuln.Name == kv.Name && lib.Name == kv.DetailedName && lib.DetectionMethod == kv.DetectionMethod {
						vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tLibrary: %s\n\tPath: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Name, kv.ID, "Library", lib.Name, lib.Path, lib.Version, "Keep")
						//id = kv.ID
						id = fmt.Sprintf("%s-%s", vuln.Name, lib.Name)
					}
				}
				// If vulnCompare is empty and ignoreVuln is set to false, then we need to add Wiz Platform
				if vulnCompare == "" && !ignoreVuln {
					id = fmt.Sprintf("%s-%s", vuln.Name, lib.Name)
					vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tLibrary: %s\n\tPath: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Name, id, "Library", lib.Name, lib.Path, lib.Version, "Add")
				}
			}
			//fmt.Println(vulnCompare)
			if !ignoreVuln {
				// If ignoreVuln is set to false, then we will want to update the Wiz graph
				description := ""
				if lib.Path == "" {
					description = fmt.Sprintf("The library `%s` version `%s` is vulnerable to `%s`", lib.Name, lib.Version, vuln.Name)
				} else {
					description = fmt.Sprintf("The library `%s` version `%s` located at `%s` is vulnerable to `%s`", lib.Name, lib.Version, lib.Path, vuln.Name)
				}
				if vuln.FixedVersion != "" {
					description += fmt.Sprintf(", which exists in versions less than `%s`", vuln.FixedVersion)
				}
				description += fmt.Sprintf(".\nThe vulnerability was found at `%s` with vendor severity of: `%s`.\n", vuln.Source, vuln.Severity)
				if vuln.FixedVersion != "" {
					description += fmt.Sprintf("The vulnerability can be remediated by updating the library to version `%s` or higher.", vuln.FixedVersion)
				} else {
					description += "At this time there is not a fix for this vulnerability."
				}
				normalizedSeverity := normalizeAndValidateSeverity(vuln.Severity)
				vulnerability := VulnerabilityFinding{
					Id:                      id,
					Name:                    vuln.Name,
					DetailedName:            lib.Name,
					ExternalDetectionSource: "Library",
					Severity:                normalizedSeverity,
					ExternalFindingLink:     vuln.Source,
					Version:                 lib.Version,
					Source:                  "WizCLI",
					FixedVersion:            vuln.FixedVersion,
					Remediation:             vuln.FixedVersion,
					ValidatedAtRuntime:      false,
					Description:             description,
				}
				assetVulns.VulnerabilityFindings = append(assetVulns.VulnerabilityFindings, vulnerability)
			}
		}
	}

	for _, app := range scanResult.Applications {
		for _, vuln := range app.Vulnerabilities {
			// Then, compare for known vulnerabilities
			ignoreVuln := false
			newUUID := uuid.New()
			id := "WIZCLI-" + newUUID.String()
			vulnCompare := ""
			path := ""
			var err error
			for _, kv := range knownVulns {
				path, err = extractPath(kv.Description)
				if err != nil {
					path = ""
				}
				if !strings.HasPrefix(kv.ID, "WIZCLI") {
					// We are now comparing vulns found by Wiz disk scanner
					if vuln.Vulnerability.Name == kv.Name && app.Name == kv.DetailedName && vuln.Vulnerability.FixedVersion == kv.FixedVersion && app.DetectionMethod == kv.DetectionMethod {
						// Match says it's an existing vuln from Wiz disk scanner so, ignore
						vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tApplication: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Vulnerability.Name, kv.ID, "Application", app.Name, vuln.Version, "Ignore")
						id = kv.ID
						ignoreVuln = true
					}
				} else if strings.HasPrefix(kv.ID, "WIZCLI") {
					// We are now comparing vulns found by wizcli scanner
					if vuln.Vulnerability.Name == kv.Name && app.Name == kv.DetailedName && vuln.Vulnerability.FixedVersion == kv.FixedVersion && app.DetectionMethod == kv.DetectionMethod {
						vulnCompare = fmt.Sprintf("EXISTING VULN\n%s found in application %s, in version %s\n\n", vuln.Vulnerability.Name, app.Name, vuln.Version)
						id = kv.ID
					}
				}
				// If vulnCompare is empty and ignoreVuln is set to false, then we need to add Wiz Platform
				if vulnCompare == "" && !ignoreVuln {
					vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tApplication: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Vulnerability.Name, id, "Application", app.Name, vuln.Version, "Add")
				}
			}

			if !ignoreVuln {
				normalizedSeverity := normalizeAndValidateSeverity(vuln.Vulnerability.Severity)
				vulnerability := VulnerabilityFinding{
					Id:                      id,
					Name:                    vuln.Vulnerability.Name,
					DetailedName:            app.Name,
					ExternalDetectionSource: "Application",
					Severity:                normalizedSeverity,
					ExternalFindingLink:     vuln.Vulnerability.Source,
					Version:                 vuln.Version,
					Source:                  "WizCLI",
					Remediation:             vuln.Vulnerability.FixedVersion,
					ValidatedAtRuntime:      false,
					Description:             path,
				}
				assetVulns.VulnerabilityFindings = append(assetVulns.VulnerabilityFindings, vulnerability)
			}
		}
	}

	return assetVulns, nil

}

func extractPath(str string) (string, error) {
	re := regexp.MustCompile(`located at (.*?) and is vulnerable to`)
	matches := re.FindStringSubmatch(str)

	if len(matches) > 1 {
		trimmedPath := strings.Trim(matches[1], "`") // Remove backticks from start and end
		return trimmedPath, nil
	}

	// Return an empty string and an error if the path could not be extracted
	return "", errors.New("path not found in the string")
}

// normalizeAndValidateSeverity takes a string, normalizes it to have the first letter uppercase
// and the rest lowercase, and then checks if it matches allowed severity levels.
func normalizeAndValidateSeverity(input string) string {
	// Normalize the string: lowercase with an uppercase first letter
	if len(input) == 0 {
		return "None" // Return "None" if the input is empty
	}
	normalized := strings.ToUpper(input[:1]) + strings.ToLower(input[1:])

	// List of allowed severity levels
	allowedSeverities := []string{"None", "Low", "Medium", "High", "Critical"}

	// Check if the normalized string is in the list of allowed severities
	for _, severity := range allowedSeverities {
		if normalized == severity {
			return normalized
		}
	}

	// Default to "None" if no match is found
	return "None"
}
