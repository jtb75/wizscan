package vulnerability

import (
	"errors"
	"fmt"
	"regexp"
	"strings"
	"time"

	"wizscan/pkg/wizapi"
	"wizscan/pkg/wizcli"

	"github.com/google/uuid"
)

type IntegrationData struct {
	IntegrationId string       `json:"integrationId"`
	DataSources   []DataSource `json:"dataSources"`
}

type DataSource struct {
	Id           string    `json:"id"`
	AnalysisDate time.Time `json:"analysisDate"`
	Assets       []Asset   `json:"assets"`
}

type Asset struct {
	AssetIdentifier       AssetIdentifier        `json:"assetIdentifier"`
	VulnerabilityFindings []VulnerabilityFinding `json:"vulnerabilityFindings"`
}

type AssetIdentifier struct {
	CloudPlatform string `json:"cloudPlatform"`
	ProviderId    string `json:"providerId"`
}

type VulnerabilityFinding struct {
	Id                      string `json:"id"`
	Name                    string `json:"name"`
	DetailedName            string `json:"detailedName"`
	ExternalDetectionSource string `json:"externalDetectionSource"`
	Severity                string `json:"severity"`
	ExternalFindingLink     string `json:"externalFindingLink"`
	Version                 string `json:"version"`
	Source                  string `json:"source"`
	Remediation             string `json:"remediation"`
	ValidatedAtRuntime      bool   `json:"validatedAtRuntime"`
	Description             string `json:"description"`
}

func CompareVulnerabilities(scanResult wizcli.AggregatedScanResults, knownVulns []wizapi.VulnerabilityNode) {
	// Instantiate assetVulns with an empty slice of VulnerabilityFinding
	assetVulns := Asset{
		VulnerabilityFindings: make([]VulnerabilityFinding, 0),
	}

	for _, lib := range scanResult.Libraries {
		for _, vuln := range lib.Vulnerabilities {
			// Then, compare for known vulnerabilities
			ignoreVuln := false
			newUUID := uuid.New()
			id := "WIZCLI-" + newUUID.String()
			vulnCompare := ""
			path := ""
			var err error
			for _, kv := range knownVulns {
				path, err = extractPath(kv.Description)
				if err != nil {
					path = ""
				}
				if !strings.HasPrefix(kv.ID, "WIZCLI") {
					// We are now comparing vulns found by Wiz disk scanner
					if vuln.Name == kv.Name && lib.Name == kv.DetailedName && vuln.FixedVersion == kv.FixedVersion && lib.DetectionMethod == kv.DetectionMethod && lib.Path == path {
						// Match says it's an existing vuln from Wiz disk scanner so, ignore
						vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tLibrary: %s\n\tPath: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Name, kv.ID, "Library", lib.Name, lib.Path, lib.Version, "Ignore")
						id = kv.ID
						ignoreVuln = true
					}
				} else if strings.HasPrefix(kv.ID, "WIZCLI") {
					// We are now comparing vulns found by wizcli scanner
					if vuln.Name == kv.Name && lib.Name == kv.DetailedName && vuln.FixedVersion == kv.FixedVersion && lib.DetectionMethod == kv.DetectionMethod {
						vulnCompare = fmt.Sprintf("EXISTING VULN\n%s found in library %s located here, %s, in version %s\n\n", vuln.Name, lib.Name, lib.Path, lib.Version)
						id = kv.ID
					}
				}
				// If vulnCompare is empty and ignoreVuln is set to false, then we need to add Wiz Platform
				if vulnCompare == "" && !ignoreVuln {
					vulnCompare = fmt.Sprintf("%s\n\tID: %s\n\tType: %s\n\tLibrary: %s\n\tPath: %s\n\tVersion: %s\n\tVerdict: %s\n\n", vuln.Name, id, "Library", lib.Name, lib.Path, lib.Version, "Add")
				}
			}
			fmt.Println(vulnCompare)
			if !ignoreVuln {
				vulnerability := VulnerabilityFinding{
					Id:                      id,
					Name:                    vuln.Name,
					DetailedName:            lib.Name,
					ExternalDetectionSource: "Library",
					Severity:                vuln.Severity,
					ExternalFindingLink:     vuln.Source,
					Version:                 lib.Version,
					Source:                  "WizCLI",
					Remediation:             vuln.FixedVersion,
					ValidatedAtRuntime:      false,
					Description:             path,
				}
				assetVulns.VulnerabilityFindings = append(assetVulns.VulnerabilityFindings, vulnerability)
			}
		}
	}

	/*
	   assetVulnsJSON, err := json.MarshalIndent(assetVulns, "", "\t")
	   if err != nil {
	       fmt.Println("Error marshaling assetVulns to JSON:", err)
	       return
	   }
	   fmt.Println(string(assetVulnsJSON))
	*/

}

func extractPath(str string) (string, error) {
	re := regexp.MustCompile(`located at (.*?) and is vulnerable to`)
	matches := re.FindStringSubmatch(str)

	if len(matches) > 1 {
		trimmedPath := strings.Trim(matches[1], "`") // Remove backticks from start and end
		return trimmedPath, nil
	}

	// Return an empty string and an error if the path could not be extracted
	return "", errors.New("path not found in the string")
}
