package wizapi

import (
	"encoding/json"
	"fmt"
	"net/http"
	"wizscan/pkg/logger"
)

const VulnerabilityQuery = `
query VulnerabilityFindingsTable($filterBy: VulnerabilityFindingFilters, $first: Int, $after: String) {
	vulnerabilityFindings(
	  filterBy: $filterBy
	  first: $first
	  after: $after
	  orderBy: {direction: DESC}
	) {
	  nodes {
		id
		name
		detailedName
		description
		severity: vendorSeverity
		weightedSeverity
		status
		fixedVersion
		detectionMethod
		hasExploit
		hasCisaKevExploit
		cisaKevReleaseDate
		cisaKevDueDate
		firstDetectedAt
		lastDetectedAt
		resolvedAt
		score
		validatedInRuntime
		epssSeverity
		epssPercentile
		epssProbability
		dataSourceName
		fixDate
		fixDateBefore
		publishedDate
		cvssv2 {
		  attackVector
		  attackComplexity
		  confidentialityImpact
		  integrityImpact
		  privilegesRequired
		  userInteractionRequired
		}
		cvssv3 {
		  attackVector
		  attackComplexity
		  confidentialityImpact
		  integrityImpact
		  privilegesRequired
		  userInteractionRequired
		}
		ignoreRules {
		  id
		}
		layerMetadata {
		  id
		  details
		  isBaseLayer
		}
		vulnerableAsset {
		  ... on VulnerableAssetBase {
			id
			type
			name
			cloudPlatform
			subscriptionName
			subscriptionExternalId
			subscriptionId
			tags
			hasLimitedInternetExposure
			hasWideInternetExposure
			isAccessibleFromVPN
			isAccessibleFromOtherVnets
			isAccessibleFromOtherSubscriptions
		  }
		  ... on VulnerableAssetVirtualMachine {
			id
			type
			name
			cloudPlatform
			subscriptionName
			subscriptionExternalId
			subscriptionId
			tags
			operatingSystem
			imageName
			imageId
			imageNativeType
			hasLimitedInternetExposure
			hasWideInternetExposure
			isAccessibleFromVPN
			isAccessibleFromOtherVnets
			isAccessibleFromOtherSubscriptions
		  }
		  ... on VulnerableAssetServerless {
			id
			type
			name
			cloudPlatform
			subscriptionName
			subscriptionExternalId
			subscriptionId
			tags
			hasLimitedInternetExposure
			hasWideInternetExposure
			isAccessibleFromVPN
			isAccessibleFromOtherVnets
			isAccessibleFromOtherSubscriptions
		  }
		  ... on VulnerableAssetContainerImage {
			id
			type
			name
			cloudPlatform
			subscriptionName
			subscriptionExternalId
			subscriptionId
			tags
			hasLimitedInternetExposure
			hasWideInternetExposure
			isAccessibleFromVPN
			isAccessibleFromOtherVnets
			isAccessibleFromOtherSubscriptions
			repository {
			  vertexId
			  name
			}
			registry {
			  vertexId
			  name
			}
			scanSource
			executionControllers {
			  ...VulnerableAssetExecutionControllerDetails
			}
		  }
		  ... on VulnerableAssetContainer {
			id
			type
			name
			cloudPlatform
			subscriptionName
			subscriptionExternalId
			subscriptionId
			tags
			hasLimitedInternetExposure
			hasWideInternetExposure
			isAccessibleFromVPN
			isAccessibleFromOtherVnets
			isAccessibleFromOtherSubscriptions
			executionControllers {
			  ...VulnerableAssetExecutionControllerDetails
			}
		  }
		}
	  }
	  pageInfo {
		hasNextPage
		endCursor
	  }
	}
  }
	  
	  fragment VulnerableAssetExecutionControllerDetails on VulnerableAssetExecutionController {
	id
	entityType
	externalId
	providerUniqueId
	name
	subscriptionExternalId
	subscriptionId
	subscriptionName
	ancestors {
	  id
	  name
	  entityType
	  externalId
	  providerUniqueId
	}
  }
`

// GraphQLVar represents the variables for the GraphQL vulnerability query.
type VulnerabilityVar struct {
	First           int    `json:"first"`
	After           string `json:"after,omitempty"` // Added field for pagination cursor
	FetchTotalCount bool   `json:"fetchTotalCount"` // Added field to control fetching of total count
	FilterBy        struct {
		AssetID []string `json:"assetId"`
	} `json:"filterBy"`
}

// GraphQLVulnerabilityResponse represents the entire GraphQL response.
type GraphQLVulnerabilityResponse struct {
	Data GraphQLVulnerabilityResponseData `json:"data"`
}

// GraphQLVulnerabilityResponseData represents the data structure within the GraphQL response.
type GraphQLVulnerabilityResponseData struct {
	VulnerabilityFindings VulnerabilityFindings `json:"vulnerabilityFindings"`
}

// VulnerabilityFindings represents the findings of a vulnerability query.
type VulnerabilityFindings struct {
	Nodes    []VulnerabilityNode `json:"nodes"`
	PageInfo PageInfo            `json:"pageInfo"`
}

// VulnerabilityNode represents an individual vulnerability.
type VulnerabilityNode struct {
	ID              string `json:"id"`
	Name            string `json:"name"`
	DetailedName    string `json:"detailedName"`
	FixedVersion    string `json:"fixedVersion"`
	DetectionMethod string `json:"detectionMethod"`
	Score           string `json:"score"`
	DataSourceName  string `json:"dataSourceName"`
	PublishedDate   string `json:"publishedDate"`
}

// PageInfo represents pagination information for GraphQL queries.
type PageInfo struct {
	HasNextPage bool   `json:"hasNextPage"`
	EndCursor   string `json:"endCursor"`
}

// createVulnerabilityQueryVar creates a VulnerabilityVar for the vulnerability query with the given assetId and pagination cursor.
func createVulnerabilityQueryVar(assetId string, nextPage string) VulnerabilityVar {
	variable := VulnerabilityVar{
		First: 30,
		FilterBy: struct {
			AssetID []string `json:"assetId"`
		}{
			AssetID: []string{assetId},
		},
	}

	// Check if nextPage is not empty and assign it to the After field
	if nextPage != "" {
		variable.After = nextPage
	}

	return variable
}

// FetchAllVulnerabilities retrieves all vulnerabilities for a given resource ID.
func FetchAllVulnerabilities(client *WizAPI, resourceId string) ([]VulnerabilityNode, error) {
	var allVulnerabilities []VulnerabilityNode // Initialized as an empty slice
	var endCursor string
	hasNextPage := true
	pageCounter := 1

	for hasNextPage {
		logger.Log.Debug("Fetching vulnerabilities, Page: ", pageCounter)

		variablesStruct := createVulnerabilityQueryVar(resourceId, endCursor)

		var variablesMap map[string]interface{}
		variablesBytes, err := json.Marshal(variablesStruct)
		if err != nil {
			return nil, fmt.Errorf("error marshaling variables: %w", err)
		}
		if err := json.Unmarshal(variablesBytes, &variablesMap); err != nil {
			return nil, fmt.Errorf("error unmarshaling variables: %w", err)
		}

		httpResponse, err := client.QueryWithRetry(VulnerabilityQuery, variablesMap)
		if err != nil {
			return nil, err
		}
		defer httpResponse.Body.Close()

		if httpResponse.StatusCode != http.StatusOK {
			return nil, fmt.Errorf("query failed with status code: %d", httpResponse.StatusCode)
		}

		var tempResponse GraphQLVulnerabilityResponse
		if err := json.NewDecoder(httpResponse.Body).Decode(&tempResponse); err != nil {
			return nil, fmt.Errorf("error decoding response: %w", err)
		}

		// Append the vulnerabilities from this page
		allVulnerabilities = append(allVulnerabilities, tempResponse.Data.VulnerabilityFindings.Nodes...)

		hasNextPage = tempResponse.Data.VulnerabilityFindings.PageInfo.HasNextPage
		endCursor = tempResponse.Data.VulnerabilityFindings.PageInfo.EndCursor
		pageCounter += 1
	}

	// If there were no results, allVulnerabilities remains an empty slice
	return allVulnerabilities, nil
}
